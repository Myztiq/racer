// Generated by CoffeeScript 1.3.3
(function() {
  var Track, b2AABB, b2Body, b2BodyDef, b2CircleShape, b2DebugDraw, b2Fixture, b2FixtureDef, b2MassData, b2MouseJointDef, b2PolygonShape, b2Vec2, b2World, getRandomArbitary,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  b2Vec2 = Box2D.Common.Math.b2Vec2;

  b2AABB = Box2D.Collision.b2AABB;

  b2BodyDef = Box2D.Dynamics.b2BodyDef;

  b2Body = Box2D.Dynamics.b2Body;

  b2FixtureDef = Box2D.Dynamics.b2FixtureDef;

  b2Fixture = Box2D.Dynamics.b2Fixture;

  b2World = Box2D.Dynamics.b2World;

  b2MassData = Box2D.Collision.Shapes.b2MassData;

  b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;

  b2CircleShape = Box2D.Collision.Shapes.b2CircleShape;

  b2DebugDraw = Box2D.Dynamics.b2DebugDraw;

  b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef;

  getRandomArbitary = function(min, max) {
    return Math.random() * (max - min) + min;
  };

  Track = (function() {
    var debugged;

    function Track(world, graphics) {
      var _this = this;
      this.world = world;
      this.graphics = graphics;
      this.update = __bind(this.update, this);

      this.drawObj = __bind(this.drawObj, this);

      this.obstacles = [];
      this.img = new Image();
      this.img.src = "/images/brick.jpg";
      this.img.onload = function() {
        return _this.loaded = true;
      };
      this.addObstacle({
        x: 0,
        y: 13,
        angle: 0,
        length: 0,
        right: {
          x: 0,
          y: 0
        },
        left: {
          x: 0,
          y: 0
        }
      });
    }

    Track.prototype.drawObj = function(obj, track) {
      var body;
      if (this.loaded) {
        body = new createjs.Shape();
        body.graphics.beginBitmapFill(this.img).drawRoundRect(0, 0, obj.length * scale * 2, .2 * scale * 2, 5);
        body.regX = obj.length * scale;
        body.regY = .2 * scale;
        return this.graphics.trackObject(body, track);
      }
    };

    Track.prototype.addObstacle = function(lastObjData) {
      var bodyDef, customDrawData, difference, fixDef, maxAngle, maxAngleDifference, maxLength, minAngle, minLength, newAngle, oldAngle, ramp;
      maxAngle = 40;
      minAngle = maxAngle * -1;
      maxAngleDifference = 30;
      maxLength = 2;
      minLength = .4;
      newAngle = getRandomArbitary(maxAngle, minAngle);
      oldAngle = lastObjData.angle;
      difference = 0;
      if (newAngle > oldAngle) {
        difference = newAngle - oldAngle;
        if (difference > maxAngleDifference) {
          newAngle = oldAngle + maxAngleDifference;
        }
      } else {
        difference = oldAngle - newAngle;
        if (difference > maxAngleDifference) {
          newAngle = oldAngle - maxAngleDifference;
        }
      }
      customDrawData = {
        length: getRandomArbitary(maxLength, minLength),
        angle: newAngle
      };
      customDrawData.left = {
        x: customDrawData.length * Math.cos(customDrawData.angle / (180 / Math.PI)) * -1,
        y: customDrawData.length * Math.sin(customDrawData.angle / (180 / Math.PI)) * -1
      };
      customDrawData.right = {
        x: customDrawData.length * Math.cos(customDrawData.angle / (180 / Math.PI)),
        y: customDrawData.length * Math.sin(customDrawData.angle / (180 / Math.PI))
      };
      customDrawData.x = lastObjData.right.x + lastObjData.x + -1 * customDrawData.left.x;
      customDrawData.y = lastObjData.right.y + lastObjData.y + -1 * customDrawData.left.y;
      fixDef = new b2FixtureDef;
      fixDef.shape = new b2PolygonShape;
      bodyDef = new b2BodyDef;
      bodyDef.type = b2Body.b2_staticBody;
      fixDef.shape.SetAsBox(customDrawData.length, .2);
      bodyDef.position.Set(customDrawData.x, customDrawData.y);
      ramp = this.world.CreateBody(bodyDef);
      ramp.CreateFixture(fixDef);
      ramp.SetAngle(customDrawData.angle / (180 / Math.PI));
      ramp.length = length;
      this.obstacles.push(customDrawData);
      return this.drawObj(customDrawData, ramp);
    };

    debugged = 0;

    Track.prototype.update = function() {
      var carPosition, lastObstacle;
      carPosition = game.car.carBody.GetWorldCenter();
      lastObstacle = this.obstacles[this.obstacles.length - 1];
      if (carPosition.x + 20 > lastObstacle.x) {
        return this.addObstacle(lastObstacle);
      }
    };

    return Track;

  })();

  window.Track = Track;

}).call(this);
