// Generated by CoffeeScript 1.3.3
(function() {
  var Track, b2AABB, b2Body, b2BodyDef, b2CircleShape, b2DebugDraw, b2Fixture, b2FixtureDef, b2MassData, b2MouseJointDef, b2PolygonShape, b2Vec2, b2World, getRandomArbitary,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  b2Vec2 = Box2D.Common.Math.b2Vec2;

  b2AABB = Box2D.Collision.b2AABB;

  b2BodyDef = Box2D.Dynamics.b2BodyDef;

  b2Body = Box2D.Dynamics.b2Body;

  b2FixtureDef = Box2D.Dynamics.b2FixtureDef;

  b2Fixture = Box2D.Dynamics.b2Fixture;

  b2World = Box2D.Dynamics.b2World;

  b2MassData = Box2D.Collision.Shapes.b2MassData;

  b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;

  b2CircleShape = Box2D.Collision.Shapes.b2CircleShape;

  b2DebugDraw = Box2D.Dynamics.b2DebugDraw;

  b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef;

  getRandomArbitary = function(min, max) {
    return Math.random() * (max - min) + min;
  };

  Track = (function() {
    var debugged;

    function Track(world, graphics) {
      var customDrawData, ramp,
        _this = this;
      this.world = world;
      this.graphics = graphics;
      this.update = __bind(this.update, this);

      this.drawObj = __bind(this.drawObj, this);

      this.obstacles = [];
      this.loadQueue = [];
      this.img = new Image();
      this.img.src = "/images/brick.jpg";
      this.img.onload = function() {
        var queued, _i, _len, _ref, _results;
        _this.loaded = true;
        _ref = _this.loadQueue;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          queued = _ref[_i];
          _results.push(_this.drawObj(queued.obj, queued.track));
        }
        return _results;
      };
      customDrawData = {
        x: 0,
        y: 13,
        angle: 0,
        length: 20,
        right: {
          x: 20,
          y: 0
        },
        left: {
          x: 0,
          y: 0
        }
      };
      ramp = this.addPhysicsObj(customDrawData);
      this.addObstacle(customDrawData);
      this.drawObj(customDrawData, ramp);
    }

    Track.prototype.drawObj = function(obj, track) {
      var body;
      if (this.loaded) {
        body = new createjs.Shape();
        body.graphics.beginBitmapFill(this.img).drawRoundRect(0, 0, obj.length * scale * 2, .2 * scale * 2, 5);
        body.regX = obj.length * scale;
        body.regY = .2 * scale;
        return this.graphics.trackObject(body, track);
      } else {
        return this.loadQueue.push({
          obj: obj,
          track: track
        });
      }
    };

    Track.prototype.addPhysicsObj = function(customDrawData) {
      var bodyDef, fixDef, ramp;
      fixDef = new b2FixtureDef;
      fixDef.shape = new b2PolygonShape;
      bodyDef = new b2BodyDef;
      bodyDef.type = b2Body.b2_staticBody;
      fixDef.shape.SetAsBox(customDrawData.length, .2);
      bodyDef.position.Set(customDrawData.x, customDrawData.y);
      ramp = this.world.CreateBody(bodyDef);
      ramp.CreateFixture(fixDef);
      ramp.SetAngle(customDrawData.angle / (180 / Math.PI));
      return ramp;
    };

    Track.prototype.removePhysicsObj = function(obj) {
      return this.world.DestroyBody(obj);
    };

    Track.prototype.cleanupTrack = function(currentX) {
      var cleanupIndex, cleanupThreshold, i, obstacle, _i, _len, _ref;
      cleanupThreshold = 100;
      cleanupIndex = 0;
      _ref = this.obstacles;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        obstacle = _ref[i];
        if (obstacle.physicsObj.GetWorldCenter().x + cleanupThreshold < currentX) {
          this.removePhysicsObj(obstacle.physicsObj);
          cleanupIndex = i;
        } else {
          break;
        }
      }
      if (cleanupIndex > 0) {
        return this.obstacles.splice(0, cleanupIndex);
      }
    };

    Track.prototype.addObstacle = function(lastObjData) {
      var customDrawData, difference, maxAngle, maxAngleDifference, maxLength, minAngle, minLength, newAngle, oldAngle, ramp;
      maxAngle = 40;
      minAngle = maxAngle * -1;
      maxAngleDifference = 30;
      maxLength = 4;
      minLength = .2;
      newAngle = getRandomArbitary(maxAngle, minAngle);
      oldAngle = lastObjData.angle;
      difference = 0;
      if (newAngle > oldAngle) {
        difference = newAngle - oldAngle;
        if (difference > maxAngleDifference) {
          newAngle = oldAngle + maxAngleDifference;
        }
      } else {
        difference = oldAngle - newAngle;
        if (difference > maxAngleDifference) {
          newAngle = oldAngle - maxAngleDifference;
        }
      }
      customDrawData = {
        length: getRandomArbitary(maxLength, minLength),
        angle: newAngle
      };
      customDrawData.left = {
        x: customDrawData.length * Math.cos(customDrawData.angle / (180 / Math.PI)) * -1,
        y: customDrawData.length * Math.sin(customDrawData.angle / (180 / Math.PI)) * -1
      };
      customDrawData.right = {
        x: customDrawData.length * Math.cos(customDrawData.angle / (180 / Math.PI)),
        y: customDrawData.length * Math.sin(customDrawData.angle / (180 / Math.PI))
      };
      customDrawData.x = lastObjData.right.x + lastObjData.x + -1 * customDrawData.left.x;
      customDrawData.y = lastObjData.right.y + lastObjData.y + -1 * customDrawData.left.y;
      ramp = this.addPhysicsObj(customDrawData);
      this.drawObj(customDrawData, ramp);
      customDrawData.physicsObj = ramp;
      return this.obstacles.push(customDrawData);
    };

    debugged = 0;

    Track.prototype.update = function() {
      var carPosition, lastObstacle;
      carPosition = game.car.carBody.GetWorldCenter();
      lastObstacle = this.obstacles[this.obstacles.length - 1];
      if (carPosition.x + 20 > lastObstacle.x) {
        this.addObstacle(lastObstacle);
        return this.cleanupTrack(carPosition.x);
      }
    };

    return Track;

  })();

  window.Track = Track;

}).call(this);
